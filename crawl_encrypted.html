<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Secrets secrets secrets!</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Secrets secrets secrets!</p>
                        <p><p>Solve the easy puzzle - Our WiFI</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Unlock"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"777fb30fb10169c2d8a651645e385ed82aea6710a732032fbf227c36fcea05e93893db7e71e29686f5d07d637ae470161773b5b29f7f3107a08665ed331c9c502fd41b2bbf4ac9f1c580590aa9ab8aa3f051071e1bde2a55b82b5b93bbd4b2d3a14305a9ed33ba103a5c115ac8a341420ec651a6c817edff4d8d21e7debf5db9e68fa65600a4dc694102fd85a3e9867e5deb775920e3d6073da327a95b650b6be92c44f50069b3c35e3d60955acfe0fd086d4511253b2ba6f14bb41b5a16c85630699b55b6f0f07a3e51c00ff224530d7642a36969bb088a38e14c5de68013499d1d584d83e579fdbd808964bd7855162fc9e9e0740eae406defea425eaf3dc62bb6f6791177afaa5eb1b29bcbb19cc3a3089807b13a293d878ec8f403333cad850cf8b1922362069d9028b0da94e6645a7b2350167f9af7891a48bd9ed64be3fbcecd05ee2c582057c4ede8d58cc8f9444986e94a215cf94f0323a2dff3cc83cb02084a4301addfcc87c727eac54255574a7c9711a3bd349ea1b007f48e0c63af4c1a618414fab40725da77938bf04558ea549160627d4901c251ebb42b200c623c5f401270bafed4ba5a83bcf875f555fe15667cdb79f5c147cd6aab450f2ca8406d60aaf0167191470e06c3d1f87ee2df4c161cb4177abd468722977cf5420780e1d3150de527e454589f4297e431e14a97f1140f4cbaf0a5b4aeeefddedccecff737386019faf6231a9b4ca27e89cbcf67c262a4adcd626d59c43b4556e6d7df3d93c180a9c3cb95fa71070fd6ff876d0ab9733d42af0ec3687074515493ab182c713423f8f34b1ec05a5bb28b565db2cdc74bf3b4de930f9e4b0ee882f29b3cf7d5d6675215b38bd97515ae6e53b9025e7c39682cb9c792006c23edb48fc33e29133795822366a2c083dd04cea61d84265b482abd00b5f03ab042811f4e84374a036fce5585af5177bcaafd70527bc532a87af176a856c774d9b33d0a7fac6ee7b329e46c207cb01addd22840de5d89527303fafe823c3a0b3f4b0f0cfbffc0bdaba57c26d132b11af200cda0887dc7f1a4697109691f4e72f4f8aedf8292607ca57e600070c68bc26a8b5712d7403c087ba2a2019ec47bcc3c20da7df59f4b25d4c382d8a652d383fa7d9e5f1918e90cadd486608c71c3ca423064212d19ab1f4f5d156a595a4601bb371772e6ff639ece1efeabda26c24d16df08a9ef40c270722d97c47af30783a6944b0c6044efc0c55b8a8054b5665b841aea442b45141d10657f3bd55b1bd00b71b240ce86cd7cdf344baff585b0873166c70e2ee2ad328ea2edb88bf08b43a17d2eee7ef705d3c156abc7be5e70b1dc78a3bd3b04e215755ddf23acd0fef36ba6e9c8d9eef1eeb6779ee99151464938c1b8f1a84b6583fd777c7fc9a3b3abfd170d8855282a59bc1478eddc5d92fdafc080dc01c9114c22a8dd4bf614517be2c97dd2d10b0898e2aac8f7cba3e94207147a0f05b3656efd3cd0ecbd96f37b684a3514f424d17c7d456c04847fbf35e530a569fee7792bdebecdb2f88cddd891e89d3c74cad21f7c699071799920c3b009f3d27f29753284923001bca823e01f0c451385a85800e4000aa3b0e59297f1c8393a260c640f3033728e791f6f9d9b70f69172c224395b578c94e9d18791dd40baab7d4bd78c608855fb8b183b03c5c76882be1635a0a942ca5885f13f6a105eb67a2d123011b119ab59ef25fa9c60c117f21ec0a9ca2894d6c179df6ccb013650d06f34a9b50fa2f0b9723a0df3ed1872a933451e063a5454498559fbb9b9c3be8fa774fb1ba045236399134bbd6ccc02b4e2bea659dc06d25113470e79ac50ec2016fbbc60332d67e865d198a71067b89eb68a8702e1945be82a1a6b0bf76e0e588327137ac519def5b7ebf20b164b358e7ba073e6e55f66cde8883dbc6f6eb4886e0f9ceb749d922e2cfb1ac85539a4fb92393630ed485f4f07f1c8a368f7f7659fe35a1674fef2e219da0d4c5f2ae23dd75fdcc61f3bd399046f6a1b830332a29a0ebd8a253325a68faa393dcb59ca9550ab227dc7af3121f2913b5dc8b7d7267c79bf3b66d0eecd273a8aa7d95af7f99b1c33e76c5e76eb4b3d0eb611e2965a0c0de4066c8b3a7fc00a59a076d724c5b18f059fa2ea4232924b5d6845de4f06614a1105a705801f2656150e83d4f600d0641751ec3ea3b741b144faaae64cb62bdfd74dbcf3c3b923ad587d4e51f8871e987bb91de682b6514bc870e6f61cc72249b2ce1e5f20465e7ba7041ae8cc9440c8395a4299234a2594a36baaffd9105607aa9a487ae32749c7484dd0f7af585edf69fc05f6fb6722234776b3af88c23604400dcd6e09910806247261002923669013c2cdbbd92231baca41d0b495c87c33f5d38d9053466a3fd28cbd4e25f53c8781bd8c7fbc01abfb7617a6f457ecdd2396d1f9ce4690e39ed35af520825023847605e18d8646f1c174046bc2c24e8bfc8d570f13925ee8176afec9aecd960a7e2ca34a5311061bda29d62e26f985fee5b1af2767cb9e06b8ae4d252939f0a950c73144bb640abffde9c823a943b1160fb4c54ca0c26fd9bf563a70eec16864cb87ce3f2a4dc79d9b3d0bf5357a6ec9170101bf52fc1dbe5055e29b177f3427027a4a2c952364f0ab4a55bfd4d9fc47c029f4c5ebb5a03942394f310ea6580bff212ecdfddd22dd8d0414e1c9c386fc9eaabfbf92ff1e07d4d4565f68ff81e612f2ab4ab01c1502f7ad4540def45fa77d179b5023333c330545f45ca260342f8bf17ff2702095b673d19cd405a9299470d074327b8e6ac501f8b86e921efc4299fae3cbcc6b902ad0b8c10e45921f6d9ec8395c9bd0cfee6f7dda6e45a759f5cdf200baee344dc6958dab4c2cfabe8ffa73b27a5bbaa2fb3862b84bf1d7ad3a26eca7dcb5a6317ed2898f56b0b543ac9e0c890d0ce1740d718b7e958b26c603cce66edb7c7a80089bc70070ff684134bb9d779ffbb8ad01ed6e319e3ac9ec309ed1e0c8bb78422bfaca89576890c8bddad2dff725fa236f9ae85c778edf06d48c5276d2b4bbb2535f0bc35288a74b8b5ba7d395c7b429f9c2c8ceefc1c8de51d74e244b323dea6144a08cf91411e61c3cc2ac8ea3fbc99a1a57e717a21cde7cf84308a86efb02c53cc3efb21f999918ee11f0d4647741dbccd86232231c6f7a79a839c46dc0a62e276df0e83a549c9469c1b3297e974036290125bfdf17260823968d4412ed1548f44716b54be5105743058503cd394ef24bd598588bfc756b72ed74cd5b8b86e7e68547a761fe5311f29af020a5c1d6a68d3b84e5e519fdc7587c912ae319cde552af73ae39c7231d921f86a358bc1c6c54da4c62c35f68be01a188731bf716a86c70fee262c14f3be2ac7f112311a45db57e08e2c594934f2b167297d445fe32fc8187a1a91a7d25b9b4bb21b6efab6dbf2e5efdb7f3dbfae44e3c945904efe20beb980e5c9866e8c95bde65908bba450356e056b661e4d55e8b89b7aaa7a1fcddc80aad871e95cd69d20d31f8f9f4f31ad97f7959e734ddce04e9a6ecac663f8717a64f0bfbf60d757364f5fabfa90ef5083a7ff320e1eb4239ee7e1aba9cf7cb67b8f96e9ee3191cb61043724dae14580950c1968489e801b26e653392b70dd389cee23c796b69c45ad79d7eabe6b4702c3eae7227331f1978865d90434cec672fa94c3d9f9894819558466b9e86d222511505d8e20dc7a675908e381791cc9b710e2b70e46a649787410129e613a6e9edfff8ea9fa47ac7ef05717f5170a6ba7676bbd9d1f310da77f81f13103ee89267bbb180ac2d8d0a268b5074c231c9e674a7197067173b37c61705817dd40622eb7fc48bc796825b08d6f4be450f89fc4f787c3a22bd689945f209c8e6cf8b5cc1c806c3fa8bac4298ee4418728e36f0f508c8b01cb0fbad294409cdd6edc623a699067347d00f8eaa944aa6eb05e837d0b26f696b489e88ba057c202ea85aa4be0adfacf2734529a155083f5fb432f965f2bcb13305a40a06a354f620b9f502801e95e4ccab891a3ae5a41669c2055ba4b79c5b50147d45a6b322367ed417393a169c3fb8d8cf6df21f1b3bdefca920c3e3f5573770ace2884efab9acca4d1b8c4f684d3945994f05982f29721b2474783c4c1c664342a7a027fcf9d42938905a6f50bf5f8166251d1a822b966d66a9ddefb6c252b5f982045734a10d686f12c24b46812e482d064dec917235b2401fed27bb35ba536097f3a2d3601a5addca238455939d7b937acc965ab66255bd1551f0a8f49559c9c77e767b674784f68e4215b33d5c91d44aad64853aa7da07974bd37eda198df4452d483fd63d9e595274ec8194d9d5e56ca759248bf62dbb3adcd73be451d06c4e4ab822882233243911ce8d1ccba144cddf8019b295731359760622a3b152a1d754c2d95561d0ea82069b4476ea6d927fecc9e4175ee7a51e75a9ebfbd845de52815d04a7f084851712c6d6e480a1f49f5557220f6c1e79ab8021d02cd2300bda1088f4da63105b7e81083b8bff2b1a73139e0ec3415e51f0e74b00114e986fbd37922c159acddc474414944c4b4e40f1fcd1e2a4802d50c46f09379902d639d6f08acf15071bb39c7ec4312bbf25e8abf3192f0a1e9d3b2288a2a9797b40aceca404da50bd141c0f657099d53507a8e4c6671967bf7d78a3c1d4a32c6224ad8b956872c2082297bc1b515a47f97ad5a34f4d0ef6ab726eb2c3a6f50447af628e4ef345ea438a941229c36ee3424bf8fbf1588208dbdc2e448e46551d56d14566c417c1c2c721e59bb1f07dc4a627f02acf5a7c5840f2f7608d15fc459a06cb4a9bd887f3821d139109278256c6b16a2eee149a6532acf4fa729c64d7a8ecd44eb7419181324d28b4c9cc5d3aa2a92443d2db6a47dc42000a11625b92bca7cc21c897ddb30e707e539eaec7339d007f4bbb8d6ae6e58c1e0968a539a3695c68820d3a8fe12268c8d6be855bcf33254c719af95cfdb5db9b0563b168a4ae77a591a3482c6aa2b09fe412e89ceede9026411839cfb036be1c62a7cfb0db130fa65d86463c0cdc5e9a309570bbbc6e1617ac47dca02684f1f85c3155494b81fbd40511195d7e88084451199f08a55be56087f06b89c0007ec72131fe3e506fc03ae8414fa1cbbf4b826ab9677e4fd10b1f9565d8fde727b4b3ce9ae890ef852f280fd82c9e3d3b5b873cc5d3eb02ce4871f119b211466d30a04424265121138bd4e9839c1465a4dc0e9ed9c2f852534cadf2b703b641ee5cd298fd3824e33739f4d0f5515fc70eaff14ade99a56275187de7d3339a9662b31554014b2f6115a8e3afd1647fe70e11e63eb6d683c55120976e59c661dd962a53770345c147a896a15cca66400cafd17ee3ccda36d85f8047cecab711b46fae5aa384bbac6c8642acf5f75c2bad5674c0836235756d2f846ceee7d2a9a4567a8268d56c6ef6c8c28e26d727b5430e744afbc39d98ae3813129e53c81bc10354b54c4030da699dc0e0d5ae050e8a17ab6246b68d0eac9beac06f87d62cb77a61fb9246bcf6dbd30b71bf6d749427a55bc6d1b710d028bda9796bebcda337169743775220c4c89c73d1fc6ebc467952220b046f78bb62336302054318ed910ccecc620a20b0c44fed85cd855fe60647c7d19db403c00608854b3ce0ff3051b1ded34fc17c5c0572cc957f15d365438b3f0371099360a967e49575992656d5242b93f6669704f94fa08fe63e76ab892493869cfe6fd4e850bd8827bf4290d770243af72ad9433c4ef9af9a8aee335916136ce9549c9cc344aafef272e9d6cbbe4b82d87647218091f1ac135cf523e20b82d9fc696881d015110fba0f65380eafb533b7a6f697ad70f8f67876ae3a71c09f46580bc9145e0e0dbcf05ae99b2277a454131b14bb742f040e21faf62aae9e0a54f497a40f64884267d7b3f45741448d496ca0c2a5ac3a9c82a47b7aec2adc0eac2074ed3f3945e507caedb86991f77a4e3906650722cc84d3f9a12f5d61eaa6717277958731d71d04cc93e1a122df08e9d27f5118ed6c3e7db8ab08c621130efdb38a482ee10520e8695d68fc5a73d7860db7c119f291c39c2e655c4469f01fbd21ef15f050ba9767677d196456eb4e5db2766293705b393df2ccc4d9d623e960f4c418f76c964da49bd954bc2d8f99dc46182fac861da44e7707a972a295790614d17f698b1e8a6d78fcbcd6a4781cdde5e21d3a13d5eca60f64ecaa9ed6072d00611b48f767637591faa9340736aaaed8e4aac3b060fcee8350dcd102c6f1bb2417ae3b55adb0a2883ea374b29e874690d4231f7faf05e926d00608573bef19eb3d9f4086e5e64acb58897a95bbb73ea530076f216ce896783745aa0423e61f6f5272afad7cce6998fb9792213da99b2789049b8940cffdc09cb03a4f3550e69fe11c1ea5b623d3b04c92fb9a5508157956e054294a5ff7cc4d51ea7a0fe440a9e2cda508663cd8ad07770b573739c8e3c35ea560a36e06cd6785e822776ef2b01b7bef7098c931fecfb3e22955b7d6a0be8bb8e4f02ccd43d737be6a2441cc53aca00274fa3d16bb3c679b73d53a258f25d10ee694e630b19c9af3295ea0cdf63413bb526c2b181cfd8ec1e7e3a89f5a5a4fd7cc6de0f29da8f940a9c8534ed0ae8edec6f2c0d1e75d4b334d52c9c18fa0100e26d48cf8730d189e48a0c3dfc4ca9d1d39267660073880023e80be2176656364336c2661721b6cb348c8a8b864d82e4f8a1900b344f051bdccf2481762d4d831f43ac6b3e84b3806230cc0225b971cfeab9fad0e539a8e09f77a575cd0ddf37f53d1c3f4b2cfd5a9027d7676fb32bb8436f295dda0f22f0f7ed1f7ee6c5757adc3ac7ffd085c38a717d6a86c016af2b251fe30aa25e5ea93ffa2608e8a06bc7f81ebacc68583cb296395d31c1166fc626e372f05ac5a57b8047e230a4c734902bd03ef8bad4dd22c8334f28aaea727d31da08c76cc4d1425fbd7093f9dca193e773e0486ac40f4840defde10fdada22bb6a3068e75bd73c96754c47448ecff95b3382c2cffb6f4724d0bea7cdbc54cf11d8f69cc09582f0c5f07d4b508a15e5366b764f7de340074e34b2a74b1511aa1af037165c02b22a19092e2fdf865af0ac1e8ff9b65d27b44de098ca4a301ed3d115f88ccd4ec429e722a17216bd352b26dafe01c1e9a2b0d1908cc6781c17e2ce5d0d7e5af0289aef757a4a7e19904200e261320f13db1a920c2f70a2137daff3637972930d4b4bc9ec8e4765d1fb9353da9f9867ba9f9cc2e0be34e6e73fe4d2e9e608ab816238ae2295779f466008b0da3c0279bb53ac9184c00e943141f41c008a7a93a06cc44c25b52ad6625645c7fabf28a47545f02b8c19e961d3bc2f1da0ca5195471067f6cadf3ddd915c597b8819c1543c2f1e2cdaa7d80f9dbe06ef2d1d98cea30e593d937eed77a6a5be77e0ba8b7bd113050b96dc20e2a0406c8fb364d0ef48366d7b5d0f85ac442dfffb513e7eda62e227ab7c98ca7b924fca507f964ba6e568e35ff1665919883cdffc9aa4993559fc1a63c94f1181375b6edcad3f3961db379fbb85b50ab5f176b9f40e64af5c46f2a2e7c3b106ff4d15dc4a73841dbf6ee54dabc3a3b590bb24b3fee8e69c566f2df90181e4a7945fb4e09f3c1646c4a8a80bdacbe5072b1169741e8e6fcc79fc5bdbd00cd38b48dd13351b1148074f7c908813602aa1c3bbd8f2e3fbec7da00cf63fd4afb9317929e263e0a6979a976e706ae07c3ea66a0cf84ec85c0490e920f46709d518b9f6765c17edceb11a20b37404e6b0948a87b10d423607122fad525960f3b71a3e8fe1dcfd5a382e446a5fb27e52ddd68413744c457e7f8ff357ba60d3d0ffbf6d65361edb38d31d584e316432a70019d715b8fbe15b3d7438133830786d98f623e47762dbc9d04273c2cf7eaa106d26a5eb2a356c4730f587569acc77ebe58205ccaa57e3fb2687996d0a29527d6cf6681c1d8ef26a0eec1122991d3154f8610a6e35a0edb7e49f98d54111c1c87cab802be4290c11913aa4f69dc60802060c1076bc8a8e2611fd80950cb6334db29938ab72f264c102426e44235dac31f47b06356f00d44e5ca9a5d8cbc9d3a79e8c73b5b4f5533820cd40bdf1196474dd21a67fc6b20297da51cc4d76a06ef65d87e8c087448d442bf69f27fb94a9f12cd66c358f3043dd43d2efb410d5bbad35a7c1a5a9367f1ae577b4aa4d360dd460075cad14b930466bcba7dec47f16e76ebd95300f30c8583d21be77d25387a0938319ec10ee75c604d0c41440536668c817369e9702982cbf3eb97ba96c32bb6d40ec5386fcf7d8bb3947aec922d12f51a7b691ad33e3df7fcb197fc943758198a85ec3774a856a0f0ce8c2e4ee98880fdfc078541e1bda281fdb6","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"638756b46d1039c728f019d47bd434a4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
